import { isPlatformServer } from '@angular/common';
import { Directive, HostListener, Inject, Input, Optional, PLATFORM_ID, Self, } from '@angular/core';
import _Inputmask from 'inputmask';
import { InputMaskConfig, INPUT_MASK_CONFIG } from './config';
import * as i0 from "@angular/core";
import * as i1 from "@angular/forms";
import * as i2 from "./config";
// The initial issue: https://github.com/ngneat/input-mask/issues/40
// Webpack 5 has module resolution changes. Libraries should configure the `output.export`
// (https://webpack.js.org/configuration/output/#outputlibraryexport) property when published in
// a UMD format, to tell Webpack that there's a default export.
// The `_Inputmask` is an object with 2 properties: `{ __esModule: true, default: Inputmask }`.
// But we want to be backwards-compatible, so we try to read the `default` property first; otherwise, we fall back to `_Inputmask`.
// eslint-disable-next-line @typescript-eslint/naming-convention
const InputmaskConstructor = _Inputmask.default ||
    _Inputmask;
export class InputMaskDirective {
    constructor(platformId, elementRef, renderer, ngControl, config, ngZone) {
        this.platformId = platformId;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.ngControl = ngControl;
        this.ngZone = ngZone;
        this.inputMaskPlugin = null;
        this.nativeInputElement = null;
        this.defaultInputMaskConfig = new InputMaskConfig();
        this.inputMaskOptions = null;
        /* The original `onChange` function coming from the `setUpControl`. */
        this.onChange = () => { };
        this.mutationObserver = null;
        this.onInput = (_) => { };
        this.onTouched = (_) => { };
        this.validate = (control) => !control.value || !this.inputMaskPlugin || this.inputMaskPlugin.isValid()
            ? null
            : { inputMask: true };
        if (this.ngControl != null) {
            this.ngControl.valueAccessor = this;
        }
        this.setNativeInputElement(config);
    }
    /**
     * Helps you to create input-mask based on https://github.com/RobinHerbots/Inputmask
     * Supports form-validation out-of-the box.
     * Visit https://github.com/ngneat/input-mask for more info.
     */
    set inputMask(inputMask) {
        if (inputMask) {
            this.inputMaskOptions = inputMask;
            this.updateInputMask();
        }
    }
    ngOnInit() {
        if (this.control) {
            this.control.setValidators(this.control.validator
                ? [this.control.validator, this.validate]
                : [this.validate]);
            this.control.updateValueAndValidity();
        }
    }
    ngOnDestroy() {
        this.removeInputMaskPlugin();
        this.mutationObserver?.disconnect();
    }
    writeValue(value) {
        if (this.nativeInputElement) {
            this.renderer.setProperty(this.nativeInputElement, 'value', value ?? '');
        }
    }
    registerOnChange(onChange) {
        this.onChange = onChange;
        const parser = this.inputMaskOptions?.parser;
        this.onInput = (value) => {
            this.onChange(parser && value ? parser(value) : value);
        };
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(disabled) {
        if (this.nativeInputElement) {
            this.renderer.setProperty(this.nativeInputElement, 'disabled', disabled);
        }
    }
    updateInputMask() {
        this.removeInputMaskPlugin();
        this.createInputMaskPlugin();
        // This re-creates the `onInput` function since `inputMaskOptions` might be changed and the `parser`
        // property now differs.
        this.registerOnChange(this.onChange);
    }
    createInputMaskPlugin() {
        const { nativeInputElement, inputMaskOptions } = this;
        if (isPlatformServer(this.platformId) ||
            !nativeInputElement ||
            inputMaskOptions === null ||
            Object.keys(inputMaskOptions).length === 0) {
            return;
        }
        const { parser, ...options } = inputMaskOptions;
        this.inputMaskPlugin = this.ngZone.runOutsideAngular(() => new InputmaskConstructor(options).mask(nativeInputElement));
        if (this.control) {
            setTimeout(() => {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.control.updateValueAndValidity();
            });
        }
    }
    get control() {
        return this.ngControl?.control;
    }
    setNativeInputElement(config) {
        if (this.elementRef.nativeElement.tagName === 'INPUT') {
            this.nativeInputElement = this.elementRef.nativeElement;
        }
        else {
            this.defaultInputMaskConfig = {
                ...this.defaultInputMaskConfig,
                ...config,
            };
            if (this.defaultInputMaskConfig.isAsync) {
                // Create an observer instance linked to the callback function
                this.mutationObserver = new MutationObserver((mutationsList) => {
                    for (const mutation of mutationsList) {
                        if (mutation.type === 'childList') {
                            const nativeInputElement = this.elementRef.nativeElement.querySelector(this.defaultInputMaskConfig.inputSelector);
                            if (nativeInputElement) {
                                this.nativeInputElement = nativeInputElement;
                                this.mutationObserver?.disconnect();
                                this.createInputMaskPlugin();
                            }
                        }
                    }
                });
                // Start observing the target node for configured mutations
                this.mutationObserver.observe(this.elementRef.nativeElement, {
                    childList: true,
                    subtree: true,
                });
            }
            else {
                this.nativeInputElement = this.elementRef.nativeElement.querySelector(this.defaultInputMaskConfig.inputSelector);
            }
        }
    }
    removeInputMaskPlugin() {
        this.inputMaskPlugin?.remove();
        this.inputMaskPlugin = null;
    }
}
InputMaskDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.0", ngImport: i0, type: InputMaskDirective, deps: [{ token: PLATFORM_ID }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i1.NgControl, optional: true, self: true }, { token: INPUT_MASK_CONFIG }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
InputMaskDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.0.0", type: InputMaskDirective, selector: "[inputMask]", inputs: { inputMask: "inputMask" }, host: { listeners: { "input": "onInput($event.target.value)", "blur": "onTouched($event.target.value)" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.0", ngImport: i0, type: InputMaskDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[inputMask]',
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i1.NgControl, decorators: [{
                    type: Optional
                }, {
                    type: Self
                }] }, { type: i2.InputMaskConfig, decorators: [{
                    type: Inject,
                    args: [INPUT_MASK_CONFIG]
                }] }, { type: i0.NgZone }]; }, propDecorators: { inputMask: [{
                type: Input
            }], onInput: [{
                type: HostListener,
                args: ['input', ['$event.target.value']]
            }], onTouched: [{
                type: HostListener,
                args: ['blur', ['$event.target.value']]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXQtbWFzay5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ25lYXQvaW5wdXQtbWFzay9zcmMvbGliL2lucHV0LW1hc2suZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ25ELE9BQU8sRUFDTCxTQUFTLEVBRVQsWUFBWSxFQUNaLE1BQU0sRUFDTixLQUFLLEVBSUwsUUFBUSxFQUNSLFdBQVcsRUFFWCxJQUFJLEdBQ0wsTUFBTSxlQUFlLENBQUM7QUFRdkIsT0FBTyxVQUFVLE1BQU0sV0FBVyxDQUFDO0FBSW5DLE9BQU8sRUFBRSxlQUFlLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxVQUFVLENBQUM7Ozs7QUFFOUQsb0VBQW9FO0FBQ3BFLDBGQUEwRjtBQUMxRixnR0FBZ0c7QUFDaEcsK0RBQStEO0FBQy9ELCtGQUErRjtBQUMvRixtSUFBbUk7QUFFbkksZ0VBQWdFO0FBQ2hFLE1BQU0sb0JBQW9CLEdBQ3ZCLFVBQXdELENBQUMsT0FBTztJQUNqRSxVQUFVLENBQUM7QUFLYixNQUFNLE9BQU8sa0JBQWtCO0lBOEI3QixZQUMrQixVQUFrQixFQUN2QyxVQUE4QyxFQUM5QyxRQUFtQixFQUNBLFNBQTJCLEVBQzNCLE1BQXVCLEVBQzFDLE1BQWM7UUFMTyxlQUFVLEdBQVYsVUFBVSxDQUFRO1FBQ3ZDLGVBQVUsR0FBVixVQUFVLENBQW9DO1FBQzlDLGFBQVEsR0FBUixRQUFRLENBQVc7UUFDQSxjQUFTLEdBQVQsU0FBUyxDQUFrQjtRQUU5QyxXQUFNLEdBQU4sTUFBTSxDQUFRO1FBakJ4QixvQkFBZSxHQUE4QixJQUFJLENBQUM7UUFDbEQsdUJBQWtCLEdBQTRCLElBQUksQ0FBQztRQUNuRCwyQkFBc0IsR0FBRyxJQUFJLGVBQWUsRUFBRSxDQUFDO1FBRXZDLHFCQUFnQixHQUErQixJQUFJ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Qy9CLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDO0lBQzlCLENBQUM7OytHQS9LVSxrQkFBa0Isa0JBK0JuQixXQUFXLHFIQUlYLGlCQUFpQjttR0FuQ2hCLGtCQUFrQjsyRkFBbEIsa0JBQWtCO2tCQUg5QixTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSxhQUFhO2lCQUN4Qjs7MEJBZ0NJLE1BQU07MkJBQUMsV0FBVzs7MEJBR2xCLFFBQVE7OzBCQUFJLElBQUk7OzBCQUNoQixNQUFNOzJCQUFDLGlCQUFpQjtpRUF2QnZCLFNBQVM7c0JBRFosS0FBSztnQkFrQ04sT0FBTztzQkFETixZQUFZO3VCQUFDLE9BQU8sRUFBRSxDQUFDLHFCQUFxQixDQUFDO2dCQUk5QyxTQUFTO3NCQURSLFlBQVk7dUJBQUMsTUFBTSxFQUFFLENBQUMscUJBQXFCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1BsYXRmb3JtU2VydmVyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgSG9zdExpc3RlbmVyLFxuICBJbmplY3QsXG4gIElucHV0LFxuICBOZ1pvbmUsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPcHRpb25hbCxcbiAgUExBVEZPUk1fSUQsXG4gIFJlbmRlcmVyMixcbiAgU2VsZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBBYnN0cmFjdENvbnRyb2wsXG4gIENvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICBOZ0NvbnRyb2wsXG4gIFZhbGlkYXRpb25FcnJvcnMsXG4gIFZhbGlkYXRvcixcbn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IF9JbnB1dG1hc2sgZnJvbSAnaW5wdXRtYXNrJztcbmltcG9ydCB0eXBlIElucHV0bWFzayBmcm9tICdpbnB1dG1hc2snO1xuXG5pbXBvcnQgeyBJbnB1dG1hc2tPcHRpb25zIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBJbnB1dE1hc2tDb25maWcsIElOUFVUX01BU0tfQ09ORklHIH0gZnJvbSAnLi9jb25maWcnO1xuXG4vLyBUaGUgaW5pdGlhbCBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL25nbmVhdC9pbnB1dC1tYXNrL2lzc3Vlcy80MFxuLy8gV2VicGFjayA1IGhhcyBtb2R1bGUgcmVzb2x1dGlvbiBjaGFuZ2VzLiBMaWJyYXJpZXMgc2hvdWxkIGNvbmZpZ3VyZSB0aGUgYG91dHB1dC5leHBvcnRgXG4vLyAoaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL291dHB1dC8jb3V0cHV0bGlicmFyeWV4cG9ydCkgcHJvcGVydHkgd2hlbiBwdWJsaXNoZWQgaW5cbi8vIGEgVU1EIGZvcm1hdCwgdG8gdGVsbCBXZWJwYWNrIHRoYXQgdGhlcmUncyBhIGRlZmF1bHQgZXhwb3J0LlxuLy8gVGhlIGBfSW5wdXRtYXNrYCBpcyBhbiBvYmplY3Qgd2l0aCAyIHByb3BlcnRpZXM6IGB7IF9fZXNNb2R1bGU6IHRydWUsIGRlZmF1bHQ6IElucHV0bWFzayB9YC5cbi8vIEJ1dCB3ZSB3YW50IHRvIGJlIGJhY2t3YXJkcy1jb21wYXRpYmxlLCBzbyB3ZSB0cnkgdG8gcmVhZCB0aGUgYGRlZmF1bHRgIHByb3BlcnR5IGZpcnN0OyBvdGhlcndpc2UsIHdlIGZhbGwgYmFjayB0byBgX0lucHV0bWFza2AuXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmNvbnN0IElucHV0bWFza0NvbnN0cnVjdG9yID1cbiAgKF9JbnB1dG1hc2sgYXMgdW5rbm93biBhcyB7IGRlZmF1bHQ/OiBJbnB1dG1hc2suU3RhdGljIH0pLmRlZmF1bHQgfHxcbiAgX0lucHV0bWFzaztcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2lucHV0TWFza10nLFxufSlcbmV4cG9ydCBjbGFzcyBJbnB1dE1hc2tEaXJlY3RpdmU8VCA9IGFueT5cbiAgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSwgQ29udHJvbFZhbHVlQWNjZXNzb3IsIFZhbGlkYXRvclxue1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9pbnB1dE1hc2s6IElucHV0bWFza09wdGlvbnM8YW55PiB8IG51bGwgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEhlbHBzIHlvdSB0byBjcmVhdGUgaW5wdXQtbWFzayBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vUm9iaW5IZXJib3RzL0lucHV0bWFza1xuICAgKiBTdXBwb3J0cyBmb3JtLXZhbGlkYXRpb24gb3V0LW9mLXRoZSBib3guXG4gICAqIFZpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS9uZ25lYXQvaW5wdXQtbWFzayBmb3IgbW9yZSBpbmZvLlxuICAgKi9cbiAgQElucHV0KClcbiAgc2V0IGlucHV0TWFzayhpbnB1dE1hc2s6IElucHV0bWFza09wdGlvbnM8VD4gfCBudWxsIHwgdW5kZWZpbmVkKSB7XG4gICAgaWYgKGlucHV0TWFzaykge1xuICAgICAgdGhpcy5pbnB1dE1hc2tPcHRpb25zID0gaW5wdXRNYXNrO1xuICAgICAgdGhpcy51cGRhdGVJbnB1dE1hc2soKTtcbiAgICB9XG4gIH1cblxuICBpbnB1dE1hc2tQbHVnaW46IElucHV0bWFzay5JbnN0YW5jZSB8IG51bGwgPSBudWxsO1xuICBuYXRpdmVJbnB1dEVsZW1lbnQ6IEhUTUxJbnB1dEVsZW1lbnQgfCBudWxsID0gbnVsbDtcbiAgZGVmYXVsdElucHV0TWFza0NvbmZpZyA9IG5ldyBJbnB1dE1hc2tDb25maWcoKTtcblxuICBwcml2YXRlIGlucHV0TWFza09wdGlvbnM6IElucHV0bWFza09wdGlvbnM8VD4gfCBudWxsID0gbnVsbDtcblxuICAvKiBUaGUgb3JpZ2luYWwgYG9uQ2hhbmdlYCBmdW5jdGlvbiBjb21pbmcgZnJvbSB0aGUgYHNldFVwQ29udHJvbGAuICovXG4gIHByaXZhdGUgb25DaGFuZ2U6ICh2YWx1ZTogVCB8IG51bGwpID0+IHZvaWQgPSAoKSA9PiB7fTtcblxuICBwcml2YXRlIG11dGF0aW9uT2JzZXJ2ZXI6IE11dGF0aW9uT2JzZXJ2ZXIgfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0KFBMQVRGT1JNX0lEKSBwcml2YXRlIHBsYXRmb3JtSWQ6IHN0cmluZyxcbiAgICBwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWY8SFRNTElucHV0RWxlbWVudCB8IGFueT4sXG4gICAgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIEBPcHRpb25hbCgpIEBTZWxmKCkgcHVibGljIG5nQ29udHJvbDogTmdDb250cm9sIHwgbnVsbCxcbiAgICBASW5qZWN0KElOUFVUX01BU0tfQ09ORklHKSBjb25maWc6IElucHV0TWFza0NvbmZpZyxcbiAgICBwcml2YXRlIG5nWm9uZTogTmdab25lXG4gICkge1xuICAgIGlmICh0aGlzLm5nQ29udHJvbCAhPSBudWxsKSB7XG4gICAgICB0aGlzLm5nQ29udHJvbC52YWx1ZUFjY2Vzc29yID0gdGhpcztcbiAgICB9XG4gICAgdGhpcy5zZXROYXRpdmVJbnB1dEVsZW1lbnQoY29uZmlnKTtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2lucHV0JywgWyckZXZlbnQudGFyZ2V0LnZhbHVlJ10pXG4gIG9uSW5wdXQgPSAoXzogYW55KSA9PiB7fTtcblxuICBASG9zdExpc3RlbmVyKCdibHVyJywgWyckZXZlbnQudGFyZ2V0LnZhbHVlJ10pXG4gIG9uVG91Y2hlZCA9IChfOiBhbnkpID0+IHt9O1xuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNvbnRyb2wpIHtcbiAgICAgIHRoaXMuY29udHJvbC5zZXRWYWxpZGF0b3JzKFxuICAgICAgICB0aGlzLmNvbnRyb2wudmFsaWRhdG9yXG4gICAgICAgICAgPyBbdGhpcy5jb250cm9sLnZhbGlkYXRvciwgdGhpcy52YWxpZGF0ZV1cbiAgICAgICAgICA6IFt0aGlzLnZhbGlkYXRlXVxuICAgICAgKTtcblxuICAgICAgdGhpcy5jb250cm9sLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLnJlbW92ZUlucHV0TWFza1BsdWdpbigpO1xuICAgIHRoaXMubXV0YXRpb25PYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuICB9XG5cbiAgd3JpdGVWYWx1ZSh2YWx1ZTogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHRoaXMubmF0aXZlSW5wdXRFbGVtZW50KSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMubmF0aXZlSW5wdXRFbGVtZW50LCAndmFsdWUnLCB2YWx1ZSA/PyAnJyk7XG4gICAgfVxuICB9XG5cbiAgcmVnaXN0ZXJPbkNoYW5nZShvbkNoYW5nZTogKHZhbHVlOiBUIHwgbnVsbCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25DaGFuZ2UgPSBvbkNoYW5nZTtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLmlucHV0TWFza09wdGlvbnM/LnBhcnNlcjtcbiAgICB0aGlzLm9uSW5wdXQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRoaXMub25DaGFuZ2UocGFyc2VyICYmIHZhbHVlID8gcGFyc2VyKHZhbHVlKSA6IHZhbHVlKTtcbiAgICB9O1xuICB9XG5cbiAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IFZvaWRGdW5jdGlvbik6IHZvaWQge1xuICAgIHRoaXMub25Ub3VjaGVkID0gZm47XG4gIH1cblxuICB2YWxpZGF0ZSA9IChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PlxuICAgICFjb250cm9sLnZhbHVlIHx8ICF0aGlzLmlucHV0TWFza1BsdWdpbiB8fCB0aGlzLmlucHV0TWFza1BsdWdpbi5pc1ZhbGlkKClcbiAgICAgID8gbnVsbFxuICAgICAgOiB7IGlucHV0TWFzazogdHJ1ZSB9O1xuXG4gIHNldERpc2FibGVkU3RhdGUoZGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBpZiAodGhpcy5uYXRpdmVJbnB1dEVsZW1lbnQpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5uYXRpdmVJbnB1dEVsZW1lbnQsICdkaXNhYmxlZCcsIGRpc2FibGVkKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUlucHV0TWFzaygpOiB2b2lkIHtcbiAgICB0aGlzLnJlbW92ZUlucHV0TWFza1BsdWdpbigpO1xuICAgIHRoaXMuY3JlYXRlSW5wdXRNYXNrUGx1Z2luKCk7XG4gICAgLy8gVGhpcyByZS1jcmVhdGVzIHRoZSBgb25JbnB1dGAgZnVuY3Rpb24gc2luY2UgYGlucHV0TWFza09wdGlvbnNgIG1pZ2h0IGJlIGNoYW5nZWQgYW5kIHRoZSBgcGFyc2VyYFxuICAgIC8vIHByb3BlcnR5IG5vdyBkaWZmZXJzLlxuICAgIHRoaXMucmVnaXN0ZXJPbkNoYW5nZSh0aGlzLm9uQ2hhbmdlKTtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlSW5wdXRNYXNrUGx1Z2luKCk6IHZvaWQge1xuICAgIGNvbnN0IHsgbmF0aXZlSW5wdXRFbGVtZW50LCBpbnB1dE1hc2tPcHRpb25zIH0gPSB0aGlzO1xuXG4gICAgaWYgKFxuICAgICAgaXNQbGF0Zm9ybVNlcnZlcih0aGlzLnBsYXRmb3JtSWQpIHx8XG4gICAgICAhbmF0aXZlSW5wdXRFbGVtZW50IHx8XG4gICAgICBpbnB1dE1hc2tPcHRpb25zID09PSBudWxsIHx8XG4gICAgICBPYmplY3Qua2V5cyhpbnB1dE1hc2tPcHRpb25zKS5sZW5ndGggPT09IDBcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7IHBhcnNlciwgLi4ub3B0aW9ucyB9ID0gaW5wdXRNYXNrT3B0aW9ucztcbiAgICB0aGlzLmlucHV0TWFza1BsdWdpbiA9IHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+XG4gICAgICBuZXcgSW5wdXRtYXNrQ29uc3RydWN0b3Iob3B0aW9ucykubWFzayhuYXRpdmVJbnB1dEVsZW1lbnQpXG4gICAgKTtcblxuICAgIGlmICh0aGlzLmNvbnRyb2wpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICB0aGlzLmNvbnRyb2whLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGNvbnRyb2woKTogQWJzdHJhY3RDb250cm9sIHwgbnVsbCB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMubmdDb250cm9sPy5jb250cm9sO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXROYXRpdmVJbnB1dEVsZW1lbnQoY29uZmlnOiBJbnB1dE1hc2tDb25maWcpIHtcbiAgICBpZiAodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudGFnTmFtZSA9PT0gJ0lOUFVUJykge1xuICAgICAgdGhpcy5uYXRpdmVJbnB1dEVsZW1lbnQgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWZhdWx0SW5wdXRNYXNrQ29uZmlnID0ge1xuICAgICAgICAuLi50aGlzLmRlZmF1bHRJbnB1dE1hc2tDb25maWcsXG4gICAgICAgIC4uLmNvbmZpZyxcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5kZWZhdWx0SW5wdXRNYXNrQ29uZmlnLmlzQXN5bmMpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGxpbmtlZCB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG11dGF0aW9uc0xpc3QpID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9uc0xpc3QpIHtcbiAgICAgICAgICAgIGlmIChtdXRhdGlvbi50eXBlID09PSAnY2hpbGRMaXN0Jykge1xuICAgICAgICAgICAgICBjb25zdCBuYXRpdmVJbnB1dEVsZW1lbnQgPVxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRJbnB1dE1hc2tDb25maWcuaW5wdXRTZWxlY3RvclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmIChuYXRpdmVJbnB1dEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hdGl2ZUlucHV0RWxlbWVudCA9IG5hdGl2ZUlucHV0RWxlbWVudDtcbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXI/LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUlucHV0TWFza1BsdWdpbigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTdGFydCBvYnNlcnZpbmcgdGhlIHRhcmdldCBub2RlIGZvciBjb25maWd1cmVkIG11dGF0aW9uc1xuICAgICAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwge1xuICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgICBzdWJ0cmVlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubmF0aXZlSW5wdXRFbGVtZW50ID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICB0aGlzLmRlZmF1bHRJbnB1dE1hc2tDb25maWcuaW5wdXRTZWxlY3RvclxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVtb3ZlSW5wdXRNYXNrUGx1Z2luKCk6IHZvaWQge1xuICAgIHRoaXMuaW5wdXRNYXNrUGx1Z2luPy5yZW1vdmUoKTtcbiAgICB0aGlzLmlucHV0TWFza1BsdWdpbiA9IG51bGw7XG4gIH1cbn1cbiJdfQ==